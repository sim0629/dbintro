options {
  static = false;
}

PARSER_BEGIN(Parser)

package kr.sgm.sql;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;

public class Parser {
  // 키워드 목록
  //  식별자에 포함되지 않는지 확인하기 위해 사용된다.
  //  아래의 Keywords 토큰과 같은 집합을 유지해야한다.
  private static ArrayList<String> Keywords =
    new ArrayList<String>(
      Arrays.asList(
        "exit",
        "create",
        "table",
        "not",
        "null",
        "primary",
        "key",
        "foreign",
        "references",
        "int",
        "char",
        "date",
        "drop",
        "show",
        "tables",
        "desc",
        "select",
        "as",
        "from",
        "where",
        "or",
        "and",
        "is",
        "insert",
        "into",
        "values",
        "delete"
      )
    );

  // 식별자가 키워드 목록에 포함되는지 검사한다.
  // 대소문자 구분없이 비교한다.
  private static boolean isKeyword(String identifier) {
    return Keywords.contains(identifier);
  }

  private static java.text.SimpleDateFormat dateFormat =
    new java.text.SimpleDateFormat("yyyy-MM-dd");

  static {
    // 형식이 잘못된 입력에 대해 parse할 때
    // ParseException을 내도록 설정 한다.
    dateFormat.setLenient(false);
  }
}

PARSER_END(Parser)

SKIP:
{
  " "
| "\t"
| "\r"
| "\n"
}

TOKEN:
{
  < EOP: ";\r\n"|";\r"|";\n" >
| < SEMICOLON: ";" >
}

// Keywords
//  여기 사용된 토큰 스트링 집합은 Parser.Keywords와
//  같은 집합을 유지해야한다.
TOKEN:
{
  < EXIT: "exit" >
| < CREATE: "create" >
| < TABLE: "table" >
| < NOT: "not" >
| < NULL: "null" >
| < PRIMARY: "primary" >
| < KEY: "key" >
| < FOREIGN: "foreign" >
| < REFERENCES: "references" >
| < INT: "int" >
| < CHAR: "char" >
| < DATE: "date" >
| < DROP: "drop" >
| < SHOW: "show" >
| < TABLES: "tables" >
| < DESC: "desc" >
| < SELECT: "select" >
| < AS: "as" >
| < FROM: "from" >
| < WHERE: "where" >
| < OR: "or" >
| < AND: "and" >
| < IS: "is" >
| < INSERT: "insert" >
| < INTO: "into" >
| < VALUES: "values" >
| < DELETE: "delete" >
}

TOKEN:
{
  < LEGAL_IDENTIFIER: <ALPHABET>(<ALPHABET>|<UNDERSCORE>)* >
| < UNDERSCORE: "_" >
| < LEFT_PAREN: "(" >
| < RIGHT_PAREN: ")" >
| < COMMA: "," >
| < STAR: "*" >
| < PERIOD: "." >
| < COMP_OP: "<"|">"|"="|"<="|">="|"!=" >
}

TOKEN:
{
  < CHAR_STRING: <QUOTE>(~["\'"])*<QUOTE> >
| < INT_VALUE: (<SIGN>)?(<DIGIT>)+ >
| < DIGIT: ["0"-"9"] >
| < SIGN: ["+","-"] >
| < DATE_VALUE: <NNNN>"-"<NN>"-"<NN> >
| < NNNN: <DIGIT><DIGIT><DIGIT><DIGIT> >
| < NN: <DIGIT><DIGIT> >
| < QUOTE: ["\'"] >
| < ALPHABET: ["a"-"z","A"-"Z"] >
}

boolean Parse(ArrayList<BaseQuery> results):
{
  boolean exit;
}
{
  (
    < EXIT >
    { exit = true; }
  |
    QueryList(results)
    { exit = false; }
  )
  < EOP >
  { return exit; }
}

void QueryList(ArrayList<BaseQuery> results):
{
  BaseQuery result;
}
{
  result = Query()
  { results.add(result); }
  (
    < SEMICOLON >
    result = Query()
    { results.add(result); }
  )*
}

BaseQuery Query():
{
  BaseQuery result;
}
{
  (
    result = CreateTable()
  | result = DropTable()
  | result = ShowTables()
  | result = Describe()
  | result = Select()
  | result = Insert()
  | result = Delete()
  )
  { return result; }
}

CreateTableQuery CreateTable():
{
  CreateTableQuery query = new CreateTableQuery();
  String tableName;
}
{
  < CREATE >
  < TABLE >
  tableName = LegalIdentifier()
  { query.setTableName(tableName); }
  TableElementList(query)
  { return query; }
}

DropTableQuery DropTable():
{
  DropTableQuery query = new DropTableQuery();
  String tableName;
}
{
  < DROP >
  < TABLE >
  tableName = LegalIdentifier()
  { query.setTableName(tableName); }
  { return query; }
}

ShowTablesQuery ShowTables():
{
  ShowTablesQuery query = new ShowTablesQuery();
}
{
  < SHOW >
  < TABLES >
  { return query; }
}

DescribeQuery Describe():
{
  DescribeQuery query = new DescribeQuery();
  String tableName;
}
{
  < DESC >
  tableName = LegalIdentifier()
  { query.setTableName(tableName); }
  { return query; }
}

void TableElementList(CreateTableQuery query):
{}
{
  < LEFT_PAREN >
  TableElement(query)
  (
    < COMMA >
    TableElement(query)
  )*
  < RIGHT_PAREN >
}

void TableElement(CreateTableQuery query):
{
  QueryColumnDefinition columnDefinition;
}
{
  columnDefinition = ColumnDefinition()
  { query.addColumnDefinition(columnDefinition); }
| TableConstraintDefinition(query)
}

QueryColumnDefinition ColumnDefinition():
{
  String columnName;
  QueryDataType dataType;
  boolean nullable = true;
}
{
  columnName = LegalIdentifier()
  dataType = DataType()
  (
    < NOT >
    < NULL >
    { nullable = false; }
  )?
  {
    return new QueryColumnDefinition(
      columnName,
      dataType,
      nullable
    );
  }
}

void TableConstraintDefinition(CreateTableQuery query):
{
  QueryPrimaryKeyConstraint primaryKeyConstraint;
  QueryReferentialConstraint referentialConstraint;
}
{
  primaryKeyConstraint = PrimaryKeyConstraint()
  { query.addPrimaryKeyConstraint(primaryKeyConstraint); }
| referentialConstraint = ReferentialConstraint()
  { query.addReferentialConstraint(referentialConstraint); }
}

QueryDataType DataType():
{
  QueryDataType result;
  int length;
}
{
  (
    < INT >
    { result = QueryDataType.createInt(); }
  |
    < CHAR >
    < LEFT_PAREN >
    length = IntValue()
    < RIGHT_PAREN >
    { result = QueryDataType.createChar(length); }
  |
    < DATE >
    { result = QueryDataType.createDate(); }
  )
  { return result; }
}

QueryPrimaryKeyConstraint PrimaryKeyConstraint():
{
  ArrayList<String> columnNames;
}
{
  < PRIMARY >
  < KEY >
  columnNames = ColumnNameList()
  { return new QueryPrimaryKeyConstraint(columnNames); }
}

QueryReferentialConstraint ReferentialConstraint():
{
  ArrayList<String> ourColumnNames;
  String theirTableName;
  ArrayList<String> theirColumnNames;
}
{
  < FOREIGN >
  < KEY >
  ourColumnNames = ColumnNameList()
  < REFERENCES >
  theirTableName = LegalIdentifier()
  theirColumnNames = ColumnNameList()
  {
    return new QueryReferentialConstraint(
      ourColumnNames,
      theirTableName,
      theirColumnNames
    );
  }
}

ArrayList<String> ColumnNameList():
{
  ArrayList<String> columnNames = new ArrayList<String>();
  String columnName;
}
{
  < LEFT_PAREN >
  columnName = LegalIdentifier()
  { columnNames.add(columnName); }
  (
    < COMMA >
    columnName = LegalIdentifier()
    { columnNames.add(columnName); }
  )*
  < RIGHT_PAREN >
  { return columnNames; }
}

SelectQuery Select():
{
  SelectQuery query = new SelectQuery();
}
{
  < SELECT >
  SelectList(query)
  TableExpression(query)
  { return query; }
}

void SelectList(SelectQuery query):
{
  QuerySelectedColumn selectedColumn;
}
{
  < STAR >
|
  (
    selectedColumn = SelectedColumn()
    { query.addSelectedColumn(selectedColumn); }
    (
      < COMMA >
      selectedColumn = SelectedColumn()
      { query.addSelectedColumn(selectedColumn); }
    )*
  )
}

QuerySelectedColumn SelectedColumn():
{
  String tableName = null;
  String columnName;
  String alias = null;
}
{
  (
    // < PERIOD >가 있는지 확인하기 위해 토큰 두개를 미리본다.
    LOOKAHEAD(2)
    tableName = LegalIdentifier()
    < PERIOD >
  )?
  columnName = LegalIdentifier()
  (
    < AS >
    alias = LegalIdentifier()
  )?
  { return new QuerySelectedColumn(tableName, columnName, alias); }
}

void TableExpression(SelectQuery query):
{
  QueryBooleanValueExpression where;
}
{
  FromClause(query)
  (
    where = WhereClause()
    { query.setWhere(where); }
  )?
}

void FromClause(SelectQuery query):
{}
{
  < FROM >
  TableReferenceList(query)
}

void TableReferenceList(SelectQuery query):
{
  QueryReferedTable referedTable;
}
{
  referedTable = ReferedTable()
  { query.addReferedTable(referedTable); }
  (
    < COMMA >
    referedTable = ReferedTable()
    { query.addReferedTable(referedTable); }
  )*
}

QueryReferedTable ReferedTable():
{
  String tableName;
  String alias = null;
}
{
  tableName = LegalIdentifier()
  (
    < AS >
    alias = LegalIdentifier()
  )?
  { return new QueryReferedTable(tableName, alias); }
}

QueryBooleanValueExpression WhereClause():
{
  QueryBooleanValueExpression where;
}
{
  < WHERE >
  where = BooleanValueExpression()
  { return where; }
}

QueryBooleanValueExpression BooleanValueExpression():
{}
{
  BooleanTerm()
  (
    < OR >
    BooleanTerm()
  )*
  { return new QueryBooleanValueExpression(); }
}

void BooleanTerm():
{}
{
  BooleanFactor()
  (
    < AND >
    BooleanFactor()
  )*
}

void BooleanFactor():
{}
{
  (
    < NOT >
  )?
  BooleanTest()
}

void BooleanTest():
{}
{
  Predicate()
|
  ParenthesizedBooleanExpression()
}

void ParenthesizedBooleanExpression():
{}
{
  < LEFT_PAREN >
  BooleanValueExpression()
  < RIGHT_PAREN >
}

void Predicate():
{}
{
  // < IS >가 있는지 확인하기 위해 토큰 네개를 미리본다.
  LOOKAHEAD(4)
  NullPredicate()
| ComparisonPredicate()
}

void ComparisonPredicate():
{}
{
  CompOperand()
  < COMP_OP >
  CompOperand()
}

void CompOperand():
{}
{
  ComparableValue()
|
  (
    // < PERIOD >가 있는지 확인하기 위해 토큰 두개를 미리본다.
    LOOKAHEAD(2)
    LegalIdentifier() // TABLE_NAME
    < PERIOD >
  )?
  LegalIdentifier() // COLUMN_NAME
}

QueryComparableValue ComparableValue():
{
  QueryComparableValue value;
  int i;
  String s;
  Date d;
}
{
  (
    i = IntValue()
    { value = QueryComparableValue.fromInt(i); }
  | s = CharString()
    { value = QueryComparableValue.fromString(s); }
  | d = DateValue()
    { value = QueryComparableValue.fromDate(d); }
  )
  { return value; }
}

void NullPredicate():
{}
{
  (
    // < PERIOD >가 있는지 확인하기 위해 토큰 두개를 미리본다.
    LOOKAHEAD(2)
    LegalIdentifier() // TABLE_NAME
    < PERIOD >
  )?
  LegalIdentifier() // COLUMN_NAME
  NullOperation()
}

void NullOperation():
{}
{
  < IS >
  (
    < NOT >
  )?
  < NULL >
}

InsertQuery Insert():
{
  InsertQuery query = new InsertQuery();
  String tableName;
}
{
  < INSERT >
  < INTO >
  tableName = LegalIdentifier()
  { query.setTableName(tableName); }
  InsertColumnsAndSource(query)
  { return query; }
}

void InsertColumnsAndSource(InsertQuery query):
{
  ArrayList<String> columnNames;
  ArrayList<String> values;
}
{
  (
    columnNames = ColumnNameList()
    { query.setColumnNames(columnNames); }
  )?
  ValueList(query)
}

void ValueList(InsertQuery query):
{
  QueryComparableValue value;
}
{
  < VALUES >
  < LEFT_PAREN >
  value = Value()
  { query.addValue(value); }
  (
    < COMMA >
    value = Value()
    { query.addValue(value); }
  )*
  < RIGHT_PAREN >
}

QueryComparableValue Value():
{
  QueryComparableValue value;
}
{
  < NULL >
  { return null; }
| value = ComparableValue()
  { return value; }
}

DeleteQuery Delete():
{
  DeleteQuery query = new DeleteQuery();
  String tableName;
  QueryBooleanValueExpression where;
}
{
  < DELETE >
  < FROM >
  tableName = LegalIdentifier()
  { query.setTableName(tableName); }
  (
    where = WhereClause()
    { query.setWhere(where); }
  )?
  { return query; }
}

String LegalIdentifier():
{
  Token t;
}
{
  t = < LEGAL_IDENTIFIER >
  {
    String identifier = t.image.toLowerCase();
    // 식별자가 키워드일 경우 예외를 발생한다.
    // 키워드 토큰은 대소문자 구분을 해서 소문자만 되지만
    // 식별자는 대소문자 구분을 하지 않으므로
    // 이러한 예외처리가 필요하다.
    if(isKeyword(identifier))
      throw new ParseException();
    return identifier;
  }
}

int IntValue():
{
  Token t;
}
{
  t = < INT_VALUE >
  {
    try {
      return Integer.parseInt(t.image);
    }catch(NumberFormatException ex) {
      // INT_VALUE 토큰의 정의에 의해
      // 이 예외가 발생하는 경우는
      // int 값이 32bit를 넘어갈 때이다.
      throw new ParseException();
    }
  }
}

String CharString():
{
  Token t;
}
{
  t = < CHAR_STRING >
  {
    return t.image.substring(
      1,
      t.image.length() - 1
    );
  }
}

Date DateValue():
{
  Token t;
}
{
  t = < DATE_VALUE >
  {
    try {
      return dateFormat.parse(t.image);
    }catch(java.text.ParseException ex) {
      // 자체 ParseException으로 바꾸어 던진다.
      throw new ParseException();
    }
  }
}
