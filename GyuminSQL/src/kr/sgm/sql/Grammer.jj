options {
  static = false;
}

PARSER_BEGIN(Parser)

package kr.sgm.sql;

import java.util.ArrayList;
import java.util.Arrays;

public class Parser {
  private static String PROMPT = "SQL_2009-11744> ";

  // 키워드 목록
  //  식별자에 포함되지 않는지 확인하기 위해 사용된다.
  //  아래의 Keywords 토큰과 같은 집합을 유지해야한다.
  private static ArrayList<String> Keywords =
    new ArrayList<String>(
      Arrays.asList(
        "exit",
        "create",
        "table",
        "not",
        "null",
        "primary",
        "key",
        "foreign",
        "references",
        "int",
        "char",
        "date",
        "drop",
        "show",
        "tables",
        "desc",
        "select",
        "as",
        "from",
        "where",
        "or",
        "and",
        "is",
        "insert",
        "into",
        "values",
        "delete"
      )
    );

  // 식별자가 키워드 목록에 포함되는지 검사한다.
  // 대소문자 구분없이 비교한다.
  private static boolean isKeyword(String identifier) {
    return Keywords.contains(identifier.toLowerCase());
  }

  public static void main(String[] args) {
    while(true) {
      System.out.print(PROMPT);
      Parser parser = new Parser(System.in);
      // 파싱 결과를 저장할 리스트.
      ArrayList<String> results = new ArrayList<String>();
      try {
        try {
          // Parse는 종료할지를 boolean 값으로 리턴한다.
          // 파싱 결과를 리턴값으로 받지 않고
          // 결과를 담을 리스트를 인자로 넘기는 이유는
          // ParseException이 발생하는 경우에도
          // 그 직전까지의 결과를 알기 위함이다.
          if(parser.Parse(results)) break;
        }finally {
          // Parse가 Exception을 발생하든 안하든 실행되는 block이다.
          for(String result : results)
            System.out.printf("\"%s\" requested\n", result);
        }
      }catch(ParseException ex) {
        System.out.println("Syntax error");
      }
    }
  }
}

PARSER_END(Parser)

SKIP:
{
  " "
| "\t"
| "\r"
| "\n"
}

TOKEN:
{
  < EOP: ";\r\n"|";\r"|";\n" >
| < SEMICOLON: ";" >
}

// Keywords
//  여기 사용된 토큰 스트링 집합은 Parser.Keywords와
//  같은 집합을 유지해야한다.
TOKEN:
{
  < EXIT: "exit" >
| < CREATE: "create" >
| < TABLE: "table" >
| < NOT: "not" >
| < NULL: "null" >
| < PRIMARY: "primary" >
| < KEY: "key" >
| < FOREIGN: "foreign" >
| < REFERENCES: "references" >
| < INT: "int" >
| < CHAR: "char" >
| < DATE: "date" >
| < DROP: "drop" >
| < SHOW: "show" >
| < TABLES: "tables" >
| < DESC: "desc" >
| < SELECT: "select" >
| < AS: "as" >
| < FROM: "from" >
| < WHERE: "where" >
| < OR: "or" >
| < AND: "and" >
| < IS: "is" >
| < INSERT: "insert" >
| < INTO: "into" >
| < VALUES: "values" >
| < DELETE: "delete" >
}

TOKEN:
{
  < LEGAL_IDENTIFIER: <ALPHABET>(<ALPHABET>|<UNDERSCORE>)* >
| < UNDERSCORE: "_" >
| < LEFT_PAREN: "(" >
| < RIGHT_PAREN: ")" >
| < COMMA: "," >
| < STAR: "*" >
| < PERIOD: "." >
| < COMP_OP: "<"|">"|"="|"<="|">="|"!=" >
}

TOKEN:
{
  < CHAR_STRING: <QUOTE>(~["\'"])*<QUOTE> >
| < INT_VALUE: (<SIGN>)?(<DIGIT>)+ >
| < DIGIT: ["0"-"9"] >
| < SIGN: ["+","-"] >
| < DATE_VALUE: <NNNN>"-"<NN>"-"<NN> >
| < NNNN: <DIGIT><DIGIT><DIGIT><DIGIT> >
| < NN: <DIGIT><DIGIT> >
| < QUOTE: ["\'"] >
| < ALPHABET: ["a"-"z","A"-"Z"] >
}

boolean Parse(ArrayList<String> results):
{
  boolean exit;
}
{
  (
    < EXIT >
    { exit = true; }
  |
    QueryList(results)
    { exit = false; }
  )
  < EOP >
  { return exit; }
}

void QueryList(ArrayList<String> results):
{
  String result;
}
{
  result = Query()
  { results.add(result); }
  (
    < SEMICOLON >
    result = Query()
    { results.add(result); }
  )*
}

String Query():
{
  String result;
}
{
  (
    CreateTable()
    { result = "create table"; }
  | DropTable()
    { result = "drop table"; }
  | ShowTables()
    { result = "show tables"; }
  | Describe()
    { result = "desc"; }
  | Select()
    { result = "select"; }
  | Insert()
    { result = "insert"; }
  | Delete()
    { result = "delete"; }
  )
  { return result; }
}

void CreateTable():
{}
{
  < CREATE >
  < TABLE >
  LegalIdentifier() // TABLE_NAME
  TableElementList()
}

void DropTable():
{}
{
  < DROP >
  < TABLE >
  LegalIdentifier() // TABLE_NAME
}

void ShowTables():
{}
{
  < SHOW >
  < TABLES >
}

void Describe():
{}
{
  < DESC >
  LegalIdentifier() // TABLE_NAME
}

void TableElementList():
{}
{
  < LEFT_PAREN >
  TableElement()
  (
    < COMMA >
    TableElement()
  )*
  < RIGHT_PAREN >
}

void TableElement():
{}
{
  ColumnDefinition()
| TableConstraintDefinition()
}

void ColumnDefinition():
{}
{
  LegalIdentifier() // COLUMN_NAME
  DataType()
  (
    < NOT >
    < NULL >
  )?
}

void TableConstraintDefinition():
{}
{
  PrimaryKeyConstraint()
| ReferentialConstraint()
}

void DataType():
{}
{
  < INT >
|
  < CHAR >
  < LEFT_PAREN >
  < INT_VALUE >
  < RIGHT_PAREN >
|
  < DATE >
}

void PrimaryKeyConstraint():
{}
{
  < PRIMARY >
  < KEY >
  ColumnNameList()
}

void ReferentialConstraint():
{}
{
  < FOREIGN >
  < KEY >
  ColumnNameList()
  < REFERENCES >
  LegalIdentifier() // TABLE_NAME
  ColumnNameList()
}

void ColumnNameList():
{}
{
  < LEFT_PAREN >
  LegalIdentifier() // COLUMN_NAME
  (
    < COMMA >
    LegalIdentifier() // COLUMN_NAME
  )*
  < RIGHT_PAREN >
}

void Select():
{}
{
  < SELECT >
  SelectList()
  TableExpression()
}

void SelectList():
{}
{
  < STAR >
|
  (
    SelectedColumn()
    (
      < COMMA >
      SelectedColumn()
    )*
  )
}

void SelectedColumn():
{}
{
  (
    // < PERIOD >가 있는지 확인하기 위해 토큰 두개를 미리본다.
    LOOKAHEAD(2)
    LegalIdentifier() // TABLE_NAME
    < PERIOD >
  )?
  LegalIdentifier() // COLUMN_NAME
  (
    < AS >
    LegalIdentifier() // COLUMN_NAME
  )?
}

void TableExpression():
{}
{
  FromClause()
  (
    WhereClause()
  )?
}

void FromClause():
{}
{
  < FROM >
  TableReferenceList()
}

void TableReferenceList():
{}
{
  ReferedTable()
  (
    < COMMA >
    ReferedTable()
  )*
}

void ReferedTable():
{}
{
  LegalIdentifier() // TABLE_NAME
  (
    < AS >
    LegalIdentifier() // TABLE_NAME
  )?
}

void WhereClause():
{}
{
  < WHERE >
  BooleanValueExpression()
}

void BooleanValueExpression():
{}
{
  BooleanTerm()
  (
    < OR >
    BooleanTerm()
  )*
}

void BooleanTerm():
{}
{
  BooleanFactor()
  (
    < AND >
    BooleanFactor()
  )*
}

void BooleanFactor():
{}
{
  (
    < NOT >
  )?
  BooleanTest()
}

void BooleanTest():
{}
{
  Predicate()
|
  ParenthesizedBooleanExpression()
}

void ParenthesizedBooleanExpression():
{}
{
  < LEFT_PAREN >
  BooleanValueExpression()
  < RIGHT_PAREN >
}

void Predicate():
{}
{
  // < IS >가 있는지 확인하기 위해 토큰 네개를 미리본다.
  LOOKAHEAD(4)
  NullPredicate()
| ComparisonPredicate()
}

void ComparisonPredicate():
{}
{
  CompOperand()
  < COMP_OP >
  CompOperand()
}

void CompOperand():
{}
{
  ComparableValue()
|
  (
    // < PERIOD >가 있는지 확인하기 위해 토큰 두개를 미리본다.
    LOOKAHEAD(2)
    LegalIdentifier() // TABLE_NAME
    < PERIOD >
  )?
  LegalIdentifier() // COLUMN_NAME
}

void ComparableValue():
{}
{
  < INT_VALUE >
| < CHAR_STRING >
| < DATE_VALUE >
}

void NullPredicate():
{}
{
  (
    // < PERIOD >가 있는지 확인하기 위해 토큰 두개를 미리본다.
    LOOKAHEAD(2)
    LegalIdentifier() // TABLE_NAME
    < PERIOD >
  )?
  LegalIdentifier() // COLUMN_NAME
  NullOperation()
}

void NullOperation():
{}
{
  < IS >
  (
    < NOT >
  )?
  < NULL >
}

void Insert():
{}
{
  < INSERT >
  < INTO >
  LegalIdentifier() // TABLE_NAME
  InsertColumnsAndSource()
}

void InsertColumnsAndSource():
{}
{
  (
    ColumnNameList()
  )?
  ValueList()
}

void ValueList():
{}
{
  < VALUES >
  < LEFT_PAREN >
  Value()
  (
    < COMMA >
    Value()
  )*
  < RIGHT_PAREN >
}

void Value():
{}
{
  < NULL >
| ComparableValue()
}

void Delete():
{}
{
  < DELETE >
  < FROM >
  LegalIdentifier() // TABLE_NAME
  (
    WhereClause()
  )?
}

void LegalIdentifier():
{
  Token t;
}
{
  t = < LEGAL_IDENTIFIER >
  {
    // 식별자가 키워드일 경우 예외를 발생한다.
    // 키워드 토큰은 대소문자 구분을 해서 소문자만 되지만
    // 식별자는 대소문자 구분을 하지 않으므로
    // 이러한 예외처리가 필요하다.
    if(isKeyword(t.image))
      throw new ParseException();
  }
}
